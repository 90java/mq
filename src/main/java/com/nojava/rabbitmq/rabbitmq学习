mq:
主要解决应用解耦，异步消息，流量削锋等问题，实现高性能，高可用，可伸缩和最终一致性架构。
----------
管理界面:rabbitmq-plugins.bat enable rabbitmq_management
重启服务器：net stop RabbitMQ && net start RabbitMQ
https://www.rabbitmq.com/getstarted.html
https://www.rabbitmq.com/tutorials/tutorial-one-java.html
http://localhost:15672/#/
参考：
https://blog.csdn.net/hellozpc/article/details/81436980#4_172
https://blog.csdn.net/cairuojin/article/details/81912033   RabbitMQ入门学习
https://blog.csdn.net/HD243608836/article/details/80217591 消息队列mq总结（重点看，比较了主流消息队列框架）
https://blog.csdn.net/alinshen/article/details/80583214  一个用消息队列 的人，不知道为啥用 MQ，这就有点尴尬
https://www.cnblogs.com/weirdo-lenovo/p/10660671.html RabbitMQ原理图
https://blog.51cto.com/wyait/1977544 rabbitMQ消息队列原理
https://www.cnblogs.com/data2value/p/6220859.html 吞吐量（TPS）、QPS、并发数、响应时间（RT）概念

-----------
<dependency>
  <groupId>com.rabbitmq</groupId>
  <artifactId>amqp-client</artifactId>
  <version>5.7.3</version>
</dependency>

1 "Hello World!"
    一个生产 一个消费
2 work queues
    一个生产 多个消费
    轮询发给消费者

    消息确认   用于当消费这挂球了。 消息丢了怎么办。
    -为了确保消息永不丢失，RabbitMQ支持 消息确认。消费者发送回一个确认（告知），告知RabbitMQ特定的消息已被接收，处理，并且RabbitMQ可以自由删除它。
    -如果消费者死了（其通道已关闭，连接已关闭或TCP连接丢失）而没有发送确认，RabbitMQ将了解消息未完全处理，并将重新排队。如果同时有其他消费者在线，
    它将很快将其重新分发给另一个消费者。这样，您可以确保即使工人偶尔死亡也不会丢失任何消息。
    -没有任何消息超时；消费者死亡时，RabbitMQ将重新传递消息。即使处理一条消息花费非常非常长的时间也没关系。

    private boolean noAck = false; 默认 com.rabbitmq.client.AMQP.Basic.Consume.Builder
    默认是false 表示需要确认